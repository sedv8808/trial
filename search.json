[
  {
    "objectID": "modules/module2/module2-01-apendice-01.html",
    "href": "modules/module2/module2-01-apendice-01.html",
    "title": "Pipas en R",
    "section": "",
    "text": "Pipas en R\nLas pipas o pipes en R son una forma de encadenar funciones. Generalmente, se puede utilizar los operadores: |&gt; or %&gt;%. |&gt; es nativo en R y %&gt;% viene del ecosistema tidyverse en R. En neotoma2 usamos %&gt;%.\nEste operador es muy útil pues funciona como una tubería que lleva agua de un lugar a otro. En programación, es como una línea de montaje donde los datos entran por una función, se modifican y el resultado es ingresado a la siguiente función. Esto hace que el código sea legible y más facil de escribir. También reduce el número de variables que se necesitan, ahorrando espacio en memoria.\nPor ejemplo, sin los pipes en neotoma2 para extraer un sitio y luego crear la gráfica haríamos:\n# Retrieve the site\nplot_site &lt;- neotoma2::get_sites(sitename = \"%ø%\")\n# Plot the site\nneotoma2::plotLeaflet(object = plot_site)\nEs decir, primero creamos la variable plot_site que sólo utilizaríamos una vez pero que fue necesaria para poder ejecutar la función plotLeaflet.\nCon la pipa (%&gt;%) no necesitamos crear la variable, simplemente escribimos nuestro código. Así plotLeaflet() no requiere un argumento object porque utiliza la respuesta generada por get_sites(sitename = \"%ø%\").\n#| label: pipingCode\n#| eval: false\n# get_sites and pipe. The `object` parameter for plotLeaflet will be the\n# result of the `get_sites()` function.\nget_sites(sitename = \"%ø%\") %&gt;%\n  plotLeaflet()&gt;",
    "crumbs": [
      "**Apéndice.**",
      "Pipas en R"
    ]
  },
  {
    "objectID": "modules/module1/module1-03-analisis-simple-03.html",
    "href": "modules/module1/module1-03-analisis-simple-03.html",
    "title": "Análisis Simple",
    "section": "",
    "text": "#| label: taxa\n#| echo: false\n#| setup: true\nsa_dl &lt;- readRDS('data/saDownload.RDS')\nsa_dl\nallSamp &lt;- samples(sa_dl)",
    "crumbs": [
      "**M1.**",
      "Análisis Simple"
    ]
  },
  {
    "objectID": "modules/module1/module1-03-analisis-simple-03.html#análisis-simples",
    "href": "modules/module1/module1-03-analisis-simple-03.html#análisis-simples",
    "title": "Análisis Simple",
    "section": "Análisis Simples",
    "text": "Análisis Simples\n\nTrazado Estratigráfico\nPodemos utilizar paquetes como rioja para hacer trazados estratigráficos para un único registro. Pero primero tenemos que hacer un manejo de datos diferente. A pesar de que podríamos hacer armonización nuevamente, vamos a tomar los 10 taxones más comúnes en un sitio dado los trazaremos en un diagrama estratigráfico.\nUtilizaremos la función arrange() para ordenar confrome al número de veces que un taxón aparece en un núcleo. De esta forma, podemos tomar las muestras y seleccionar los taxones que aparecen en las diez primeras filas del marco de datos plottingTaxa.\n#| label: stratiplot\n#| message: false\nplottingSite &lt;- sa_dl[[1]]\n\nplottingTaxa &lt;- taxa(plottingSite) %&gt;%\n  filter(ecologicalgroup %in% c(\"DIAT\")) %&gt;%\n  filter(elementtype == \"valve\") %&gt;%\n  arrange(desc(samples)) %&gt;% \n  head(n = 10)\n\n# Limpiar y seleccionar records de polen .\n# Repetir filtros para polen & grupos ecologicos en las muestras\nshortSamples &lt;- samples(plottingSite) %&gt;% \n  filter(datasettype == \"pollen\")\n\n# Select only pollen measured using NISP and convert to a \"wide\"\n# table, using proportions. The first column will be \"age\".\n# This turns our \"long\" table into a \"wide\" table:\nvalues &lt;- plottingSite[[2]] %&gt;%\n  samples() %&gt;%\n  toWide(ecologicalgroup = c(\"ITOP\"),\n         unit = c(\"per mille\"),\n         groupby = \"age\",\n         elementtype = NA,\n         operation = \"sum\") %&gt;%\n  arrange(age) %&gt;% na.omit()\nAparentemente, esto es una llamada compleja de comandos. Sin embargo, la función toWide() proporciona control sobre los taxones, unidades y otros elementos para que puedan ser ingresados en una matriz (depth x taxon) que muchas herramientas estadísticas como los paquetes vegan o rioja usan.\nPara crear gráficas, podemos usar strat.plot() del paquete rioja, ordenar los taxones usando puntajes promedio ponderados (wa.order). También se ha agregado un gráfico CONISS al borde del gráfico, para mostrar cómo funciona el nuevo marco de datos amplio con funciones métricas de distancia.\n#| label: plotStrigraph\n#| message: false\n#| warning: false\nclust &lt;- rioja::chclust(dist(sqrt(counts)),\n                        method = \"coniss\")\n\nplot &lt;- rioja::strat.plot(counts[,-1] * 100, yvar = counts$age,\n                  title = sa_dl[[1]]$sitename,\n                  ylabel = \"Calibrated Years BP\",\n                  xlabel = \"Diatom (%)\",\n                  y.rev = TRUE,\n                  clust = clust,\n                  wa.order = \"topleft\", scale.percent = TRUE)\n\nrioja::addClustZone(plot, clust, 4, col = \"red\")\n\n\nAnálisis Multi-proxy\n\nCode\n#| label: sillyplot\n\nspSamp &lt;- allSamp %&gt;%\n  filter(ecologicalgroup %in% c('TRSH', 'ITOP')) %&gt;%\n  filter(units %in% c('per mille', 'NISP'))\n  \nspPct &lt;- spSamp %&gt;%\n  group_by(sitename, depth) %&gt;%\n  mutate(val = ifelse(units == 'NISP', value / sum(value), value)) %&gt;%\n  ungroup() %&gt;%\n  filter(variablename %in% c('δ13C', 'δ18O', 'Pinus')) %&gt;%\n  filter(!agetype == 'Calendar years AD/BC')\n\nggplot(spPct, aes(x = val, y = age, color = sitename)) +\n  theme(legend.position=\"none\") +\n  geom_path() +\n  facet_wrap(~variablename, scale = 'free_x') +\n  coord_cartesian(ylim = c(0, 10000))",
    "crumbs": [
      "**M1.**",
      "Análisis Simple"
    ]
  },
  {
    "objectID": "modules/module1/module1-03-analisis-simple-03.html#conclusion",
    "href": "modules/module1/module1-03-analisis-simple-03.html#conclusion",
    "title": "Análisis Simple",
    "section": "Conclusion",
    "text": "Conclusion\nHemos hecho muchas cosas en este ejemplo. - Buscamos sitios utilizando nombres y parámetros geográficos. - Filtramos resultados utilizando parámetros espaciales y temporales. - Obtuvimos información de las muestras de los conjuntos de datos seleccionados. - Hicimos un análisis estratográfico básico.\n¡Esperamos que utilizen estos ejemplos como un bloque para usar en el futuro en su trabajo o para algo nuevo y divertido!",
    "crumbs": [
      "**M1.**",
      "Análisis Simple"
    ]
  },
  {
    "objectID": "modules/module1/module1-01-analisis-simple-01.html",
    "href": "modules/module1/module1-01-analisis-simple-01.html",
    "title": "Búsqueda de sitios",
    "section": "",
    "text": "Hay diferentes maneras de encontrar sitios en neotoma2. Debémos pensar en los sitios como objetos espaciales. Tienen nombre, ubicación y pueden ser encontrados bajo en contexto de unidades geopolíticas. Sin embargo, bajo el contexto de la API y del paquete de R, los sitios en sí mismos no contienen datos sobre la taxonomía, el grupo de datos o las edades. Simplemente es un contenedor al que le podemos agregar más información. Es así que cuando buscamos por sitio, lo hacemos usando los siguientes atributos (en inglés):\n\n\n\n\n\n\n\nParámetro\nDescripción\n\n\n\n\nsitename\nUn nombre válido, usando % como comodín.\n\n\nsiteid\nUn identificador numérico único del sitio en la base de datos de Neotoma.\n\n\nloc\nUn vector de caja delimitadora, GeoJSON o cadena WKT.\n\n\naltmin\nLímite inferior de altitud para los sitios.\n\n\naltmax\nLímite superior de altitud para los sitios.\n\n\ndatabase\nLa base de datos específica de donde se extraen los registros.\n\n\ndatasettype\nEl tipo de conjunto de datos (ver get_tables(datasettypes)).\n\n\ndatasetid\nIdentificador numérico único del conjunto de datos en Neotoma.\n\n\ndoi\nUn DOI válido para un conjunto de datos en Neotoma.\n\n\ngpid\nUn ID numérico único o cadena de texto que identifica una unidad geopolítica.\n\n\nkeywords\nPalabras clave únicas para muestras registradas en Neotoma.\n\n\ncontacts\nUn nombre o ID numérico de personas asociadas con los sitios.\n\n\ntaxa\nIDs numéricos únicos o nombres de taxones asociados con los sitios.\n\n\n\n\n\nHay ocasiones en las que sabremos exactamente el nombre del sitio que estamos buscando (“Lago Titicaca”), y habrà ocasiones en las que tendremos una idea aproximada sobre el nombre (por ejemplo, sabemos que el nombre es parecido a “Lago Titicaca”, o “Lake Titicaca”, pero no estamos seguros de como fue ingresado a la base de datos).\nDe forma general, utilizamos el formato: get_sites(sitename=\"XXXXX\") para buscar un sitio por nombre.\nPostgreSQL (y la API) utilizan el signo de porcentaje como comodín. De esta forma, \"%Titicaca%\" seleccionará “Lake Titicaca” y en caso de existir, también seleccionaría “Lago Titicaca” y “Pantano Titicaca”. La búsqueda tampoco distingue entre mayúsculas y minúsculas, por lo que simplemente podría escribir \"%titicaca%\".\n#| label: plot-sitename\n\nlibrary(neotoma2)\nlago_titicaca &lt;- neotoma2::get_sites(sitename = \"%titicaca%\")\nplotLeaflet(lago_titicaca)\n\n\n\nEl paquete neotoma utilizaba un cuadro delimitador para buscar por ubicación. El cuadro estaba estructurado como un vector con valores de latitud y longitud: c(xmin, ymin, xmax, ymax). En neotoma2 se puede utilizar esta misma caja delimitadora o podemos definir objetos espaciales más complejos con el paquete sf. El paquete sf nos permite trabajar con datos ráster y polígonos en R, para seleccionar sitios existentes en objetos espaciales más complejos. El parametro loc trabaja con vectores simples, objetos WKT, objetos geoJSON y objectos sf en R. Notar que el paquete neotoma2 es un función contenedora API que utiliza un URL (api.neotomadb.org).\nBuscar sitios utilizando una ubicación. En el siguiente código hay tres representaciones de Sudamérica: geoJSON, WKT y con un cuadro delimitador. También hemos transformado el elemento sa$geoJSON a un objeto del paquete sf. Podemos utilizar cualquiera de estas cuatro representaciones para trabajar con el paquete neotoma2.\n#| label:  boundingBox\n\nsa &lt;- list(geoJSON = '{\"type\": \"Polygon\",\n        \"coordinates\": [[\n            [-79.66, -5.97],\n            [-70.06, -19.07],\n            [-74.38, -55.59],\n            [-34.67, -6.52],\n            [-76.41, 8.37],\n            [-79.66, -5.97]\n            ]]}',\n        WKT = 'POLYGON ((-79.66, -5.97,\n                         -70.06, -19.07,\n                         -74.38, -55.59,\n                         -34.67, -6.52,\n                         -76.41, 8.37,\n                         -79.66, -5.97))',\n        bbox = c(-79.66, -55.59, -34.67, 8.37))\n\nsa$sf &lt;- geojsonsf::geojson_sf(sa$geoJSON)\n\nsa_sites &lt;- neotoma2::get_sites(loc = sa$sf, all_data = TRUE)\nPuedes siempre hacer un gráfico de los sites obtenidos con plot(), pero los datos perderan el contexto geográfico. La función plotLeaflet() regresa un mapa de la librería leaflet() y permite mayor personalización o agregar datos espaciales adicionales (como nuestro cuadro delimitador, sa$sf, que funciona directamente con el paquete leaflet):\n#| label: plotL\n#| setup: true\nneotoma2::plotLeaflet(sa_sites) %&gt;% \n  leaflet::addPolygons(map = ., \n                       data = sa$sf, \n                       color = \"green\")\n\n\n\n\n\n\nNeotoma R diagrama UML.\n\n\nSi observamos al diagrama UML para los objetos de neotoma2 podemos ver que hay un conjunto de funciones qeu operan a nivel de sites (sitios). Conforme vamos agregando información a los objetos sites mediante las funciones get_datasets() o get_downloads(), podemos utilizar un mayor número de funciones auxiliares. Podemos así, tomar ventaja de funciones como summary() para tener un mejor entendimiento de los diferentes tipos de datos que tenemos en este conjunto de sitios. El código a continuación regresa la tabla de resumen. Hacemos después un poco de magia con R para cambiar el formato en que los datos están siendo representados (convirtiéndolo a un objeto datatable()), pero la pieza principal es la llamada a la función summary().\n#| label: summary_sites\nneotoma2::summary(sa_sites) %&gt;%\n  DT::datatable(data = ., rownames = FALSE, \n                options = list(scrollX = \"100%\", dom = 't'))\nPodemos ver que no hay cronologías asociadas con el objeto sites. Esto es porque, por el momento, no hemos extraído la información necesaria de los dataset. Todo lo que sabemos, tras la llamada get_sites() son los tipos de conjuntos de datos con los que contamos.\n\n\n\n\nSabemos que las colecciones y los conjuntos de datos están contenidos en los sitios. Similarmente, un objeto de tipo sites contienen collectionunits que contienen datasets. En la tabla anterior podemos ver que algunos de los sitios contienen registros de diatomeas. Dicho esto, solo tenemos la información de sites, pero por conveniencia, la API devuelve información adicional sobre los conjuntos de datos lo que nos permite navegar de manera más fácil los registros.\nCon un objeto sites podemos llamar directamente a la función get_datasets(), que nos permitirá extraer metadatos sobre los conjuntos de datos. Podemos utilizar la función datasets() en cualqueir momento para obtener más información de los conjuntos de datos que un objeto sites pueda contener. Comparemos la información impresa datasets(sa_sites) contra una llamada similar utilizando el siguiente código.\n#| label: datasetsFromSites\nsa_datasets &lt;- neotoma2::get_datasets(sa_sites, all_data = TRUE)\n\ndatasets(sa_datasets)\n\n\n\nSi decidimos únicamente obtener registros de un sólo tipo de datos, o si requerimos de mayor filtración, debemos considerar filtrar antes de descargar todos los datos y muestras. Para ello, utilizaremos la función filter(). Por ejemplo, si requerimos únicamente los registros de polen con sus cronologías conocidas, podemos filtrar de la siguiente forma:\n#|label: downloads\nsa_diatom &lt;- sa_datasets %&gt;% \n  neotoma2::filter(datasettype == \"pollen\" & !is.na(age_range_young))\n\nneotoma2::summary(sa_diatom)\nPodemos ver qeu la tabla de datos se ve diferente y que hay un número menor de sitios.",
    "crumbs": [
      "**M1.**",
      "Búsqueda de sitios"
    ]
  },
  {
    "objectID": "modules/module1/module1-01-analisis-simple-01.html#búsqueda-de-sitios",
    "href": "modules/module1/module1-01-analisis-simple-01.html#búsqueda-de-sitios",
    "title": "Búsqueda de sitios",
    "section": "",
    "text": "Hay diferentes maneras de encontrar sitios en neotoma2. Debémos pensar en los sitios como objetos espaciales. Tienen nombre, ubicación y pueden ser encontrados bajo en contexto de unidades geopolíticas. Sin embargo, bajo el contexto de la API y del paquete de R, los sitios en sí mismos no contienen datos sobre la taxonomía, el grupo de datos o las edades. Simplemente es un contenedor al que le podemos agregar más información. Es así que cuando buscamos por sitio, lo hacemos usando los siguientes atributos (en inglés):\n\n\n\n\n\n\n\nParámetro\nDescripción\n\n\n\n\nsitename\nUn nombre válido, usando % como comodín.\n\n\nsiteid\nUn identificador numérico único del sitio en la base de datos de Neotoma.\n\n\nloc\nUn vector de caja delimitadora, GeoJSON o cadena WKT.\n\n\naltmin\nLímite inferior de altitud para los sitios.\n\n\naltmax\nLímite superior de altitud para los sitios.\n\n\ndatabase\nLa base de datos específica de donde se extraen los registros.\n\n\ndatasettype\nEl tipo de conjunto de datos (ver get_tables(datasettypes)).\n\n\ndatasetid\nIdentificador numérico único del conjunto de datos en Neotoma.\n\n\ndoi\nUn DOI válido para un conjunto de datos en Neotoma.\n\n\ngpid\nUn ID numérico único o cadena de texto que identifica una unidad geopolítica.\n\n\nkeywords\nPalabras clave únicas para muestras registradas en Neotoma.\n\n\ncontacts\nUn nombre o ID numérico de personas asociadas con los sitios.\n\n\ntaxa\nIDs numéricos únicos o nombres de taxones asociados con los sitios.\n\n\n\n\n\nHay ocasiones en las que sabremos exactamente el nombre del sitio que estamos buscando (“Lago Titicaca”), y habrà ocasiones en las que tendremos una idea aproximada sobre el nombre (por ejemplo, sabemos que el nombre es parecido a “Lago Titicaca”, o “Lake Titicaca”, pero no estamos seguros de como fue ingresado a la base de datos).\nDe forma general, utilizamos el formato: get_sites(sitename=\"XXXXX\") para buscar un sitio por nombre.\nPostgreSQL (y la API) utilizan el signo de porcentaje como comodín. De esta forma, \"%Titicaca%\" seleccionará “Lake Titicaca” y en caso de existir, también seleccionaría “Lago Titicaca” y “Pantano Titicaca”. La búsqueda tampoco distingue entre mayúsculas y minúsculas, por lo que simplemente podría escribir \"%titicaca%\".\n#| label: plot-sitename\n\nlibrary(neotoma2)\nlago_titicaca &lt;- neotoma2::get_sites(sitename = \"%titicaca%\")\nplotLeaflet(lago_titicaca)\n\n\n\nEl paquete neotoma utilizaba un cuadro delimitador para buscar por ubicación. El cuadro estaba estructurado como un vector con valores de latitud y longitud: c(xmin, ymin, xmax, ymax). En neotoma2 se puede utilizar esta misma caja delimitadora o podemos definir objetos espaciales más complejos con el paquete sf. El paquete sf nos permite trabajar con datos ráster y polígonos en R, para seleccionar sitios existentes en objetos espaciales más complejos. El parametro loc trabaja con vectores simples, objetos WKT, objetos geoJSON y objectos sf en R. Notar que el paquete neotoma2 es un función contenedora API que utiliza un URL (api.neotomadb.org).\nBuscar sitios utilizando una ubicación. En el siguiente código hay tres representaciones de Sudamérica: geoJSON, WKT y con un cuadro delimitador. También hemos transformado el elemento sa$geoJSON a un objeto del paquete sf. Podemos utilizar cualquiera de estas cuatro representaciones para trabajar con el paquete neotoma2.\n#| label:  boundingBox\n\nsa &lt;- list(geoJSON = '{\"type\": \"Polygon\",\n        \"coordinates\": [[\n            [-79.66, -5.97],\n            [-70.06, -19.07],\n            [-74.38, -55.59],\n            [-34.67, -6.52],\n            [-76.41, 8.37],\n            [-79.66, -5.97]\n            ]]}',\n        WKT = 'POLYGON ((-79.66, -5.97,\n                         -70.06, -19.07,\n                         -74.38, -55.59,\n                         -34.67, -6.52,\n                         -76.41, 8.37,\n                         -79.66, -5.97))',\n        bbox = c(-79.66, -55.59, -34.67, 8.37))\n\nsa$sf &lt;- geojsonsf::geojson_sf(sa$geoJSON)\n\nsa_sites &lt;- neotoma2::get_sites(loc = sa$sf, all_data = TRUE)\nPuedes siempre hacer un gráfico de los sites obtenidos con plot(), pero los datos perderan el contexto geográfico. La función plotLeaflet() regresa un mapa de la librería leaflet() y permite mayor personalización o agregar datos espaciales adicionales (como nuestro cuadro delimitador, sa$sf, que funciona directamente con el paquete leaflet):\n#| label: plotL\n#| setup: true\nneotoma2::plotLeaflet(sa_sites) %&gt;% \n  leaflet::addPolygons(map = ., \n                       data = sa$sf, \n                       color = \"green\")\n\n\n\n\n\n\nNeotoma R diagrama UML.\n\n\nSi observamos al diagrama UML para los objetos de neotoma2 podemos ver que hay un conjunto de funciones qeu operan a nivel de sites (sitios). Conforme vamos agregando información a los objetos sites mediante las funciones get_datasets() o get_downloads(), podemos utilizar un mayor número de funciones auxiliares. Podemos así, tomar ventaja de funciones como summary() para tener un mejor entendimiento de los diferentes tipos de datos que tenemos en este conjunto de sitios. El código a continuación regresa la tabla de resumen. Hacemos después un poco de magia con R para cambiar el formato en que los datos están siendo representados (convirtiéndolo a un objeto datatable()), pero la pieza principal es la llamada a la función summary().\n#| label: summary_sites\nneotoma2::summary(sa_sites) %&gt;%\n  DT::datatable(data = ., rownames = FALSE, \n                options = list(scrollX = \"100%\", dom = 't'))\nPodemos ver que no hay cronologías asociadas con el objeto sites. Esto es porque, por el momento, no hemos extraído la información necesaria de los dataset. Todo lo que sabemos, tras la llamada get_sites() son los tipos de conjuntos de datos con los que contamos.\n\n\n\n\nSabemos que las colecciones y los conjuntos de datos están contenidos en los sitios. Similarmente, un objeto de tipo sites contienen collectionunits que contienen datasets. En la tabla anterior podemos ver que algunos de los sitios contienen registros de diatomeas. Dicho esto, solo tenemos la información de sites, pero por conveniencia, la API devuelve información adicional sobre los conjuntos de datos lo que nos permite navegar de manera más fácil los registros.\nCon un objeto sites podemos llamar directamente a la función get_datasets(), que nos permitirá extraer metadatos sobre los conjuntos de datos. Podemos utilizar la función datasets() en cualqueir momento para obtener más información de los conjuntos de datos que un objeto sites pueda contener. Comparemos la información impresa datasets(sa_sites) contra una llamada similar utilizando el siguiente código.\n#| label: datasetsFromSites\nsa_datasets &lt;- neotoma2::get_datasets(sa_sites, all_data = TRUE)\n\ndatasets(sa_datasets)\n\n\n\nSi decidimos únicamente obtener registros de un sólo tipo de datos, o si requerimos de mayor filtración, debemos considerar filtrar antes de descargar todos los datos y muestras. Para ello, utilizaremos la función filter(). Por ejemplo, si requerimos únicamente los registros de polen con sus cronologías conocidas, podemos filtrar de la siguiente forma:\n#|label: downloads\nsa_diatom &lt;- sa_datasets %&gt;% \n  neotoma2::filter(datasettype == \"pollen\" & !is.na(age_range_young))\n\nneotoma2::summary(sa_diatom)\nPodemos ver qeu la tabla de datos se ve diferente y que hay un número menor de sitios.",
    "crumbs": [
      "**M1.**",
      "Búsqueda de sitios"
    ]
  },
  {
    "objectID": "modules/module0/slides/module0_01.html#obtener-ayuda-con-neotoma",
    "href": "modules/module0/slides/module0_01.html#obtener-ayuda-con-neotoma",
    "title": "Obtener ayuda en Neotoma",
    "section": "Obtener ayuda con Neotoma",
    "text": "Obtener ayuda con Neotoma"
  },
  {
    "objectID": "modules/module0/module0-02-instalacion.html",
    "href": "modules/module0/module0-02-instalacion.html",
    "title": "2. Instalación",
    "section": "",
    "text": "2. Instalación",
    "crumbs": [
      "**M0.**",
      "2. Instalación"
    ]
  },
  {
    "objectID": "modules/module0/module0-00-module-learning-outcomes.html",
    "href": "modules/module0/module0-00-module-learning-outcomes.html",
    "title": "0. Objetivos del módulo",
    "section": "",
    "text": "0. Objetivos del módulo",
    "crumbs": [
      "**M0.**",
      "0. Objetivos del módulo"
    ]
  },
  {
    "objectID": "modules/index.html",
    "href": "modules/index.html",
    "title": "Bienvenidos!",
    "section": "",
    "text": "Bienvenidos!\nEste pequeño tutorial pretende orientar al participante a utilizar el paquete de datos de neotoma2 y la base de datos de Neotoma",
    "crumbs": [
      "**M0.**",
      "Bienvenides!"
    ]
  },
  {
    "objectID": "modules/module0/module0-01-ayuda-en-neotoma.html",
    "href": "modules/module0/module0-01-ayuda-en-neotoma.html",
    "title": "1. Obtener ayuda en Neotoma",
    "section": "",
    "text": "1. Obtener ayuda en Neotoma",
    "crumbs": [
      "**M0.**",
      "1. Obtener ayuda en Neotoma"
    ]
  },
  {
    "objectID": "modules/module0/slides/module0_00.html#introducción",
    "href": "modules/module0/slides/module0_00.html#introducción",
    "title": "Objetivos del módulo",
    "section": "Introducción",
    "text": "Introducción\nEl objetivo de este documento es mostrar como usar el paquete de R para la base de datos Neotoma, neotoma2.\nLa librería neotoma2 está disponible en GitHub y actualmente la documentación sólo está en inglés - trabajamos para tenerla en español próximamente."
  },
  {
    "objectID": "modules/module0/slides/module0_00.html#qué-aprenderemos",
    "href": "modules/module0/slides/module0_00.html#qué-aprenderemos",
    "title": "Objetivos del módulo",
    "section": "¿Qué aprenderemos?",
    "text": "¿Qué aprenderemos?\nLos objetivos de aprendizaje de este taller son:\n\nAprender cómo se organiza la información dentro de Neotoma (Sitios, Unidades de colección y Conjuntos de datos)\nCómo se traduce esta estructura en el paquete neotoma2 para R:"
  },
  {
    "objectID": "modules/module0/slides/module0_00.html#section",
    "href": "modules/module0/slides/module0_00.html#section",
    "title": "Objetivos del módulo",
    "section": "",
    "text": "En R:\n\nBusqueda de sitios: Buscar sitios a partir de nombres o parámetros geográficos.\n\nFiltrar resultados: Filtración de resultados utilizando parametros temporales o espaciales.\n\nExploración de datos: Obtener información de muestras para los grupos de datos seleccionados.\n\nVisualizar datos: Realizar gráficos estratigráficos básicos."
  },
  {
    "objectID": "modules/module0/slides/module0_00.html#iniciemos",
    "href": "modules/module0/slides/module0_00.html#iniciemos",
    "title": "Objetivos del módulo",
    "section": "Iniciemos!",
    "text": "Iniciemos!"
  },
  {
    "objectID": "modules/module0/slides/module0_02.html#instalación",
    "href": "modules/module0/slides/module0_02.html#instalación",
    "title": "Instalación",
    "section": "Instalación",
    "text": "Instalación"
  },
  {
    "objectID": "modules/module0/slides/module0_02.html#cran",
    "href": "modules/module0/slides/module0_02.html#cran",
    "title": "Instalación",
    "section": "CRAN",
    "text": "CRAN\ninstall.packages('neotoma2')\nlibrary(neotoma2)"
  },
  {
    "objectID": "modules/module0/slides/module0_02.html#github-recomendado",
    "href": "modules/module0/slides/module0_02.html#github-recomendado",
    "title": "Instalación",
    "section": "Github (recomendado)",
    "text": "Github (recomendado)\nSin embargo, para instalar la versión más actualizada, es recomendable hacer (versión 1.0.6):\ninstall.packages('devtools')\ndevtools::install_github(\"NeotomaDB/neotoma2@dev\")\nlibrary(neotoma2)"
  },
  {
    "objectID": "modules/module1/module1-00-analisis-simple-00.html",
    "href": "modules/module1/module1-00-analisis-simple-00.html",
    "title": "La estrucura de Neotoma",
    "section": "",
    "text": "La estrucura de Neotoma\nLos datos en la base de datos de Neotoma están organizados como un conjunto de relaciones conectadas que permiten representar los distintos elementos de un análisis paleoecológico:\n\nEspacio y tiempo:\n\n¿Dónde está ubicada una muestra (latitud y longitud)?\n¿A qué profundidad fue tomada dentro de un perfil estratigráfico?\n¿Qué edad estimada tiene esa muestra?\n¿Qué edad tienen los elementos encontrados dentro o cerca de esa muestra?\n\nObservaciones:\n\n¿Qué se está contando o midiendo?\n¿Qué unidades se están usando?\n¿Quién lo observó?\n\nMétodos científicos\n\n¿Qué modelo estadístico se usó para calcular la edad?\n¿Qué tipo de incertidumbre se consideró para describir esa observación?\n\nModelos conceptuales de datos\n\n¿Cómo se relacionan las observaciones dentro de una muestra con otras muestras de la misma colección?\n¿Cómo se vincula una observación fósil con especies actuales o extintas relacionadas?\n\n\nLa paleoecología es un campo amplio y en constante evolución por lo que estas relaciones pueden ser bastante complejas. Por eso, la base de datos está altamente estructurada y normalizada, lo que permite agregar nuevos conocimientos sin afectar el modelo de datos central.\nSi quieres profundizar en cómo está organizada la base de datos, puedes leer el Manual de la base de datos de Neotoma o revisar directamente el esquema del modelo relacional.\n\nEstructura de Datos en Neotoma\n\n\n\nFigura. La estructura de sitios, colecciones o unidades de colecta, muestras y conjuntos de datos en Neotoma. Un sitio contiene una o mas colecciones. Las cronologías están asociadas a las colecciones y las muestras con datos de un mismo tipo (polen, diatomeas, vertebrados) se asignan a un conjunto de datos.\n\n\nEn Neotoma, los datos se asocian a sitios – ubicaciones específicas con coordenadas de latitud y longitud.\nDentro de un sitio, puede haber una o más unidades de colecta – que son los puntos específicos donde se recolectan físicamente las uestras dentro del sitio. Por ejemplo:\n\nUna cueva es un sitio que puede tener más de una colección, con entidades específicas (espeleotemas)\nUn sitio arqueológico puede tener una o más colecciones, como pozos dentro de una excavación.\nUn sitio de muestreo de polen puede tener varias colecciones – es decir, diferentes núcleos dentro de la cuenca del lago.\nUna ciénaga es un sitio que puede tener diversas colecciones – una transecta con varias muestras de superficie.\n\nLas unidades de colección pueden tener coordenadas GPS de mayor resolución que el sitio general, pero siguen considerándose parte del mismo sitio.\nLos datos dentro de una colección son recopilados a partir de diferentes unidades de análisis, por ejemplo:\n\nTodo el sedimento a 10cm de profundidad en un perfil de corte (la colección) a lo largo de un lago meándrico (el sitio) es una unidad de análisis;\nTodo el material en una muestra de superficie (colección) tomada de una ciénaga (el sitio) es una unidad de análisis;\nTodos los restos fósiles en una capa enterrada de huesos (colección) en una cueva (el sitio) también forman una unidad de análisis.\n\nLos datos recolectados en una unidad de análisis se agrupan según su tipo de conjunto de datos (carbón, diatomeas, dinoflagelados, etc.) y se organizan como una muestra. El conjunto de muestras de una colección para un tipo de datos determinado se asigna a un conjunto de datos.\n\nUna muestra puede ser todas las diatomeas (conjunto de datos) extraídas del sedimento a 12 cm de profundidad (unidad de análisis) en un núcleo (colección) de un lago (el sitio).\nOtra muestra puede ser el registro de un solo hueso de mamut (muestra y unidad de análisis, tipo de datos: vertebrados) encontrado en la ribera de un río (sitio y unidad de colección).\n\n\n\nEstructura de Datos en neotoma2\n\n\n\nFigura. Diagrama UML del paquete neotoma2 para R. Cada recuadro representa una clase de datos dentro del paquete. Cada clase muestra su nombre, propieades y funciones que se pueden aplicar a esos objetos. Por ejemplo, un objeto sites (sitios en inglés) tiene una propiedad sites que es una lista. La función plotLeaflet() puede ser utilizada en un objeto de la clase sites.\n\n\nSi observamos el diagrama UML podemos observar que la estructura de datos en el paquete neotoma2 refleja la estructura original de la base de datos.\nComo veremos en la sección Búsqueda de Sitios, podemos buscar estos objetos y empezar a trabajar con ellos (en la sección Análisis Simple).\nUn punto que debemos tener en cuenta, en el paquete neotoma2, la mayoría de los objetos son de la clase sites , que contienen mayor o menor información. Hay diferentes funciones que operan sobre sites. Cuando queremos obtener mayor información sobre los sitios sites, utilizamos las funciones get_datasets() o get_downloads() que pueblan con mayor información los sitios.",
    "crumbs": [
      "**M1.**",
      "La estrucura de Neotoma"
    ]
  },
  {
    "objectID": "modules/module1/module1-02-analisis-simple-02.html",
    "href": "modules/module1/module1-02-analisis-simple-02.html",
    "title": "Obteniendo las muestras con sample()",
    "section": "",
    "text": "Obteniendo las muestras con sample().\nDebido a que los datos de las muestras agregan mucha sobrecarga (para Sudamérica, los datos de polen sobrecargara nuestro sites object más que 20 veces), por eso llamamos la función get_downloads() después de haber hecho un filtrado preliminar. Después de get_datasets(), tenemos información sufciente para filtar basados en ubicación, límites de tiempo y tipo conjunto de datos. Cuando ejecutamosget_downloads() podemos hacer un filtrado más fino a nivel de unidad de análisis o nivel de taxón.\nEl siguiente comando puede tomar algo de tiempo. Por eso, hemos guardado el resultado en un archivo RDS. Puedes intentar correr este comando por tu cuenta o puedes cargar el archivo RDS.\n#| label: taxa\n#| setup: true\n## This line is commented out because we've already run it for you.\n##sa_dl &lt;- sa_diatom %&gt;% get_downloads(all_data = TRUE)\nsa_dl &lt;- readRDS('data/saDownload.RDS')\nUna vez que hemos hecho la descarga, ahora tenemos información de cada sitio asociado a las unidades de colecta, los tipos de conjunto de datos, y a todas las muestras asociadas a estos conjuntos. Para extraer toda las muestras, utilizamos la función samples:\n#| label: allSamples\nallSamp &lt;- samples(sa_dl)\nUna vez hecho esto, obtenemos un data.frame esto es una tabla con nrow(allSamp) renglones y ncol(allSamp) columnas. La razón de que esta tabla sea muy larga es porque estamos obteniendo los datos en un formato largo. Cada rengón contiene toda la información que se necesita para interpretarse correctamente:\n#| label: colNamesAllSamp\ncolnames(allSamp)\nPara algunos tipos de conjunto de datos o análisis específicos, algunas columnas podrán no ser necesarias. Sin embargo, para otros conjuntos de datos pueden ser críticamente importantes. Para permitir que el paquete neotoma2 sea lo más útil posible para todos los usuarios, hemos incluido todas las columnas posibles.\n\nExtracción de taxones\nSi quieres saber que taxones existen en los registros, puedes utilizar la función taxa() en el objeto sites. La función taxa() regresa los taxones únicos junto con dos columnas adicionales sites y samples que indican en cuantos sitios y en cuantas muestras el taxón aparece, esto nos ayuda a comprender mejor que tan común es cada taxón individual.\n#| label: taxa2\nneotomatx &lt;- neotoma2::taxa(sa_dl)\n\n\nEntendiendo las Taxonomías en Neotoma\nLas taxonomías en Neotoma no siempre son tan directas como podríamos pensar. La identificación taxonómica en paleoecología puede ser compleja y verse influenciada por la morfología del organismo, el estado de conservación del palinomorfo, la experiencia del/la analista, entre otros factores. Puedes leer más sobre este tema en la sección sobre Conceptos Taxonómicos del Manual de Neotoma.\nEn la base de datos utilizamos identificadores únicos (por ejemplo, taxonid, siteid, analysisunitid) porque nos permiten conectar los distintos registros entre sí. Los valores de taxonid que devuelve la función taxa() se pueden vincular con la columna taxonid en la tabla que devuelve samples(). Esto nos permite, por ejemplo, crear tablas de armonización taxonómica si lo necesitamos.\nTambién notarás que el nombre del taxón (taxonname) aparece en el campo variablename. En Neotoma, los conteos individuales de muestras se reportan como variables. Una “variable” puede representar una especie, una medición de laboratorio o incluso un proxy no orgánico, como carbón (charcoal) o mediciones de fluorescencia de rayos X (XRF). Estas variables incluyen tanto la unidad de medida como el valor correspondiente.",
    "crumbs": [
      "**M1.**",
      "Obteniendo las muestras con `sample()`"
    ]
  },
  {
    "objectID": "modules/module2/module2-00-apendice-00.html",
    "href": "modules/module2/module2-00-apendice-00.html",
    "title": "Instalar librerías",
    "section": "",
    "text": "Utilizamos varios paquetes en este documento, particularmente leaflet, sf, rioja entre otros. Podemos utilizar pacman para cargar las librerías e instalar aquellas que aún no se encuentren en su sistema.\n#| label: setupFake\n#| eval: false\noptions(warn = -1)\npacman::p_load(neotoma2, dplyr, ggplot2, sf, geojsonsf, leaflet, terra, DT, readr, stringr, rioja)\nToma en cuenta que R es sensible al orden en que las librerías son cargadas. Si utilizamos el prefijo neotoma2:: le diremos explícitamente a R que queremos utilizar una función de la librería neotoma2 para ejecutar una función en particular. Esto es porque hay funciones como filter() que existen en mas librerías como dplyr. En algunas ocaciones puedes encontrar estos errores:\nError in UseMethod(\"filter\") : \n  no applicable method for 'filter' applied to an object of class \"sites\"\nen este caso, lo más probable es que al ejecultar filter() R no sabe que debe utilizar neotoma2 y está utlizando dplyr. Agregando explícitamente dplyr:: o neotoma2:: frente a la función (i.e., neotoma2::filter()) es una buena práctica y R entenderá a que función nos referimos.",
    "crumbs": [
      "**Apéndice.**",
      "Instalar librerías"
    ]
  },
  {
    "objectID": "modules/module2/module2-00-apendice-00.html#apéndice",
    "href": "modules/module2/module2-00-apendice-00.html#apéndice",
    "title": "Instalar librerías",
    "section": "",
    "text": "Utilizamos varios paquetes en este documento, particularmente leaflet, sf, rioja entre otros. Podemos utilizar pacman para cargar las librerías e instalar aquellas que aún no se encuentren en su sistema.\n#| label: setupFake\n#| eval: false\noptions(warn = -1)\npacman::p_load(neotoma2, dplyr, ggplot2, sf, geojsonsf, leaflet, terra, DT, readr, stringr, rioja)\nToma en cuenta que R es sensible al orden en que las librerías son cargadas. Si utilizamos el prefijo neotoma2:: le diremos explícitamente a R que queremos utilizar una función de la librería neotoma2 para ejecutar una función en particular. Esto es porque hay funciones como filter() que existen en mas librerías como dplyr. En algunas ocaciones puedes encontrar estos errores:\nError in UseMethod(\"filter\") : \n  no applicable method for 'filter' applied to an object of class \"sites\"\nen este caso, lo más probable es que al ejecultar filter() R no sabe que debe utilizar neotoma2 y está utlizando dplyr. Agregando explícitamente dplyr:: o neotoma2:: frente a la función (i.e., neotoma2::filter()) es una buena práctica y R entenderá a que función nos referimos.",
    "crumbs": [
      "**Apéndice.**",
      "Instalar librerías"
    ]
  }
]